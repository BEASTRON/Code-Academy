// code from https://www.codecademy.com/courses/learn-java/lessons/introduction-to-java/exercises/whats-your-name?action=lesson_resume

public class YourName {
	public static void main(String[] args) {

		System.out.println("Beastron Carpio");

	}
}


//data types

/*The first data type we will use is int.

int is short for integer, which are all positive and negative numbers, including zero. This number could represent the number of visits a website has received or the number of programming languages you know.
The int data type only allows values between -2,147,483,648 and 2,147,483,647.*/  

public class DataTypes {
	public static void main(String[] args) {

		System.out.println(2468);

	}
}


/*he next data type we will use is the boolean.

A boolean is a data type that can only be either true or false.*/


public class DataTypesB {
	public static void main(String[] args) {

		System.out.println(true);

	}
}


/*The char data type is used to represent single characters. That includes the keys on a keyboard that are used to produce text.

char is short for character and can represent a single character.
All char values must be enclosed in single quotes, like this: 'G'.*/
  
  public class DataTypesC {
	public static void main(String[] args) {

		System.out.println('X');

	}
}


//variables

/*Another important feature of Java (and of many programming languages) is the ability to store values using variables.

A variable stores a value.
In Java, all variables must have a specified data type.
We can assign a variable to a specified data type, like this:

int myLuckyNumber = 7;
The variable myLuckyNumber now stores the value 7 as an int type.

A semicolon ; is also used to end all Java single code statements. We will cover statements that should not end in a semicolon later in this course.
*/
  
public class Variables {
	public static void main(String[] args) {

		int myNumber = 42;
		boolean isFun = true; 
		char movieRating = 'A'; 

	}
}  
  
//whitespace

/*Whitespace is one or more characters (such as a space, tab, enter, or return) that do not produce a visible mark or text. Whitespace is often used to make code visually presentable.

Java will ignore whitespace in code, but it is important to know how to use whitespace to structure code well. If you use whitespace correctly, code will be easier for you and other programmers to read and understand.*/

public class WhiteSpace {
	public static void main(String[] args) {

		boolean isFormatted = false;
    		System.out.println(isFormatted);

	}
} //line 84 - 93, correctly formatted code.

//comments

/*Single line comments are one line comments that begin with two forward slashes:
// I'm a single line comment!
Multi-line comments are generally longer comments that can span multiple lines. They begin with /* and end with */ . Here's an example:
/*

Hello, 
Java! 

*/  */  

public class Comments {
	public static void main(String[] args) {

		//System.out.println("Noise!");
		
/*Dude, I seriously looked this up online about 20 minutes ago. & this is so cutting into my SWTOR time !! :( :( */



		
	}
}

//arithmetic

/*Now let's try arithmetic in Java. You can add, subtract, multiply, and divide numbers and store them in variables like this:

int sum = 34 + 113;
int difference = 91 - 205;
int product = 2 * 8; 
int quotient = 45 / 3;  */  

public class Arithmetic {
	public static void main(String[] args) {

		int myNumber = 6*8/(2+2);
		System.out.println(myNumber);

	}
}

//modulo

/*The modulo operator - represented in Java by the % symbol - returns the remainder of dividing two numbers.
For example, 15 % 6 will return the value of 3, because that is the remainder left over after dividing 15 by 6.*/  

public class Modulo {
	public static void main(String[] args) {

		int myRemainder = 2%4;
		System.out.println(myRemainder);

	}
} 

//rational operators

/*Relational operators compare data types that have a defined ordering, like numbers (since numbers are either smaller or larger than other numbers).

Relational operators will always return a boolean value of true or false.

Here are a few relational operators:

< : less than.
<=: less than or equal to.
>: greater than.
>=: greater than or equal to.
A relational operator is placed between the two operands (the terms that you want to compare using the relational operator). The result of a relational operation is printed out in the following statement:

System.out.println(5 < 7);
The example above will print out true because the statement "5 is less than 7" is true.*/  

public class RelationalOperators {
	public static void main(String[] args) {

		System.out.println(8>=2);

	}
}


//Equality Operators

/*The equality operators are:

==: equal to.
!=: not equal to.
Equality operators do not require that operands share the same ordering. For example, you can test equality across boolean, char, or int data types. The example below combines assigning variables and using an equality operator:

char myChar = 'A';
int myInt = -2;
System.out.println(myChar == myInt);
The example above will print out false because the value of myChar ('A') is not the same value as myInt ('-2').
*/

public class EqualityOperators {
	public static void main(String[] args) {
		
    char myChar = 'X';
    
    int myInt = 12;
    
		System.out.println(myChar != myInt);

	}
}

//CONDITIONALS AND CONTROL FLOW

public class Conditionals {
	public static void main(String[] args) {


		if (1 < 4 && 0 > 5) {

			System.out.println("You ordered a cup of hot, mint tea.");

		} else if (21 <= 19 || 17 >= 28) {
			
			System.out.println("You ordered freshly squeezed orange juice!");

		} else if ( !(true == true) ) {

			System.out.println("You ordered hot cocoa!");

		} else {

			System.out.println("You ordered the arrest of Darth Envy!"); //addendum

		}

		char answerChoice = 'C';

		switch (answerChoice) {

			case 'A': System.out.println("You answered: " + answerChoice + ". Please try again.");
								break; 

			case 'B': System.out.println("You answered: " + answerChoice + ". Please try again.");
								break;

			case 'C': System.out.println("You answered: " + answerChoice + ". That is correct!");
								break;

			case 'D': System.out.println("You answered: " + answerChoice + ". Please try again.");
								break;

			default:
				System.out.println("Please select a valid answer choice.");

		}


	}
}



//Boolean Operators: &&

/*There are three Boolean operators that we will explore. Let's start with the first one: and.

The and operator is represented in Java by &&.
It returns a boolean value of true only when the expressions on both sides of && are true.
For example, the code below shows one outcome of the Boolean operator &&:

// The following expression uses the "and" Boolean operator
System.out.println(true && true); // prints true
The code below shows the rest of the possible outcomes of the Boolean operators: &&:

// The following expressions use the "and" Boolean operator
System.out.println(false && false); // prints false
System.out.println(false && true); // prints false
System.out.println(true && false); // prints false
We can also use the Boolean operator && with Boolean expressions such as the following:

System.out.println(2 < 3 && 4 < 5);
The example above will print out true because the statements "2 is less than 3" and "4 is less than 5" are both true.*/  

public class And {
	public static void main(String[] args) {

		System.out.println(true && true); //prints true.
		
	}
}

//Boolean Operators: ||

/*The or operator is represented in Java by ||.
It returns a Boolean value of true when at least one expression on either side of || is true.
The code below shows all the outcomes of the Boolean operator ||:

//The "or" Boolean operator:

System.out.println(false || false); // prints false
System.out.println(false || true); // prints true
System.out.println(true || false); // prints true
System.out.println(true || true); // prints true
We can also use the Boolean operator || with Boolean expressions such as the following:

System.out.println(2 > 1 || 3 > 4);
The example above will print out true because at least one statement — "2 is greater than 1" — is true even though the other statement — "3 is greater than 4" — is false.*/
  
public class Or {
	public static void main(String[] args) {

		System.out.println(false || false); 
		
	}
}

//Boolean Operators: !

/*The not operator is represented in Java by !.
It will return the opposite of the expression immediately after it. It will return false if the expression is true, and true if the expression is false.
The code below shows all the outcomes of the Boolean operator !:

//The "not" Boolean operator:

System.out.println(!false); // prints true
System.out.println(!true); // prints false
We can also use the Boolean operator ! with Boolean expressions such as the following:

System.out.println( !(4 <= 10) );
The example above will print out false because the statement "4 is less than or equal to 10" is true, but the ! operator will return the opposite value, which is false.*/

public class Not {
	public static void main(String[] args) {

		System.out.println(!false);
		System.out.println( !(5>=1) );
		
	}
}



//Boolean Operators: Precedence

/*The three Boolean operators &&, ||, and ! can also be used together and used multiple times to form larger Boolean expressions.

However, just like numerical operators, Boolean operators follow rules that specify the order in which they are evaluated. This order is called Boolean operator precedence.

The precedence of each Boolean operator is as follows:

! is evaluated first
&& is evaluated second
|| is evaluated third
Like numerical expressions, every expression within parentheses is evaluated first. Expressions are also read from left to right.

The following statement demonstrates how Boolean operator precedence works:

System.out.println( !(false) || true && false);
The example above will print out true. In order, the expression is evaluated as follows:

First, the ! Boolean operator in !(false) returns true.
Second, true && false evaluates to false.
Finally, the remaining expression true || false evaluates to true.*/

public class Precedence {
	public static void main(String[] args) {

		boolean riddle = !( 1 < 8 && (5 > 2 || 3 < 5));
		System.out.println(riddle);

	}
}// prints false. 


//If Statement

/*In Java, the keyword if is the first part of a conditional expression.
It is followed by a Boolean expression and then a block of code. If the Boolean expression evaluates to true, the block of code that follows will be run.
Here's an example of the if statement used with a conditional expression:

if (9 > 2) {
    System.out.println("Control flow rocks!");
}
In the example above, 9 > 2 is the Boolean expression that gets checked. Since the Boolean expression "9 is greater than 2" is true, Control flow rocks! will be printed to the console.

The if statement is not followed by a semicolon (;). Instead it uses curly braces ({ and }) to surround the code block that gets run when the Boolean expression is true.*/  

public class If {
	public static void main(String[] args) {

		if (9 > 2) {

			System.out.println("Access granted.");

		}
		
	}
}


//If-Else Statement

/*The if/else conditional will run the block of code associated with the if statement if its Boolean expression evaluates to true.
Otherwise, if the Boolean expression evaluates to false, it will run the block of code after the else keyword.
Here's an example of if/else syntax:

if (1 < 3 && 5 < 4) {
    System.out.println("I defy the Boolean laws!")
} else {
    System.out.println("You can thank George Boole!");
}
In the example above, the Boolean expression "1 is less than 3" and "5 is less than 4" evaluates to false. The code within the if block will be skipped and the code inside the else block will run instead. The text "You can thank George Boole!" will be printed in the console.*/

public class IfElse {
	public static void main(String[] args) {

		if (7 < 6) {

			System.out.println("Try again...");

		} else {

			System.out.println("Success!");

		}
		
	}
}


//If-ElseIf-Else Statement

/*If the Boolean expression after the if statement evaluates to true, it will run the code block that directly follows.
Otherwise, if the Boolean expression after the else if statement evaluates to true, the code block that directly follow will run.
Finally, if all previous Boolean expressions evaluate to false, the code within the else block will run.
Here's an example of control flow with the if/else if/else statement:

int shoeSize = 10;

if (shoeSize > 12) {
    System.out.println("Sorry, your shoe size is currently not in stock.");
} else if (shoeSize >= 6) {
    System.out.println("Your shoe size is in stock!");
} else {
    System.out.println("Sorry, this store does not carry shoes smaller than a size 6.");
}
In the example above, the int variable shoeSize is equal to 10, which is not greater than 12, but it is greater than or equal to 6. Therefore, the code block after the else if statement will be run.*/

public class IfElseIf {
	public static void main(String[] args) {

		int round = 6;

		if (round > 12) {

			System.out.println("The match is over!");

		} else if (round > 0) {

			System.out.println("The match is underway!");

		}	else {

			System.out.println("The boxing match hasn't started yet.");

		}	
	}
}



//Ternary Conditional

/*The term ternary comes from a Latin word that means "composed of three parts".

These three parts are:

A Boolean expression
A single statement that gets executed if the Boolean expression is true
A single statement that gets executed if the Boolean expression is false
Here is an example of a ternary conditional statement:

int pointsScored = 21;

char gameResult = (pointsScored > 20) ? 'W' : 'L';
System.out.println(gameResult);
In the example above, the int variable called pointsScored is equal to 21.

The Boolean expression is (pointsScored > 20), which evaluates to true. This will return the value of 'W', which is assigned to the variable gameResult. The value 'W' is printed to the console.*/  

public class Ternary {
	public static void main(String[] args) {
		
		int fuelLevel = 3;

		char canDrive = (fuelLevel > 0) ? 'Y' : 'N';
		System.out.println(canDrive);

	}
}



//Switch Statement

/*The conditional statements that we have covered so far require Boolean expressions to determine which code block to run. Java also provides a way to execute code blocks based on whether a block is equal to a specific value. For those specific cases, we can use the switch statement, which helps keep code organized and less wordy.

The switch statement is used as follows:

int restaurantRating = 3;

switch (restaurantRating) {

    case 1: System.out.println("This restaurant is not my favorite.");
      break;

    case 2: System.out.println("This restaurant is good.");
      break;

    case 3: System.out.println("This restaurant is fantastic!");
      break;

    default: System.out.println("I've never dined at this restaurant.");
      break;
}
In the example above, we assigned the int variable restaurantRating a value of 3. The code will print a message to console based on the value of restaurantRating.

In this case, This restaurant is fantastic! is printed to the console.

The break statement will exit the switch statement after a condition is met. Without the break statement, Java will continue to check whether the value of restaurantRating matches any other cases.

The default case is printed only if restaurantRating is not equal to an int with the value of 1, 2, or 3.*/

public class Switch {
	public static void main(String[] args) {
		
		char penaltyKick = 'X';

		switch (penaltyKick) {

			case 'L': System.out.println("Messi shoots to the left and scores!");
								break; 
			case 'R': System.out.println("Messi shoots to the right and misses the goal!");
								break;
			case 'C': System.out.println("Messi shoots down the center, but the keeper blocks it!");
								break;
			default:
				System.out.println("Messi is in position...");

		}

	}
}



public class Switch {
	public static void main(String[] args) {
		
		char penaltyKick = 'C';

		switch (penaltyKick) {

			case 'L': System.out.println("Messi shoots to the left and scores!");
								break; 
			case 'R': System.out.println("Messi shoots to the right and misses the goal!");
								break;
			case 'C': System.out.println("Messi shoots down the center, but the keeper blocks it!");
								break;
			default:
				System.out.println("Messi is in position...");

		}

	}
}



//Generalizations

public class GeneralizationsB {
	public static void main(String[] args) {

	// ( 3 >= 3 && !(true || true) )
	boolean tricky = false;	

	if(2016 < 2015) {

			System.out.println("Stuck in the past...");

		}else {

			System.out.println("Upgraded to the future!");

		}
	

	int subwayTrain = 5;

		switch (subwayTrain){

			case 1 : System.out.println("This is a South Ferry bound train!");
								break; 
			case 5 : System.out.println("This is a Brooklyn bound train!");
								break;
			case 7 : System.out.println("This is a Queens bound train!");
								break;
			default:
				System.out.println("I'm not sure where that train goes...");
	
		}

	}
}

//Object Oriented Overview

public class Mouse extends Rodentia {

	String name;

	public Mouse(String name) {

		this.name = name;

	}

	public void eat() {

		System.out.println(name + " ate some cheese pizza!");

	}

	public void solveMaze(int minutes) {

		System.out.println(name + " solved the maze in " + minutes + " minutes!");

	}

	public static void main(String[] args) {

		Mouse ratly = new Mouse("Ratly");
		ratly.eat();
		ratly.solveMaze(3);
		ratly.order();

	}

}



//Classes: Syntax

/*A class is a set of instructions that describe how a data structure should behave.

Java provides us with its own set of pre-defined classes, but we are also free to create our own custom classes.

Classes in Java are created as follows:

//Create a custom Car class

class Car {

}
The example above creates a class named Car. We will define the behavior of the Car data structure in the next exercise.*/

class Dog {




	public static void main(String[] args) {

	}

}

//Classes: Constructors

/*A class constructor will allow us to create Dog instances. With a class constructor, we can set some information about the Dog.
If we do not create a class constructor, Java provides one that does not allow you to set initial information.
The code below demonstrates how a class constructor is created:

class Car {

    //The class constructor for the Car class
    public Car() {

    }
}
In the example above, we created a class constructor for the Car class. This constructor will be used when we create Car instances later. The public keyword will be explained later in this course.*/

class Dog {

	//The class constructor for the Dog class
  public Dog(){
    
  }


	public static void main(String[] args) {

	}

}

//Classes: Instance Variables

/*When we create a new class, we probably have specific details that we want the class to include. We save those specific details into instance variables.

Here is an instance variable in the Car class that describes a detail that we might want to associate with a car:

class Car {

    //Using instance variables to model our Car class after a real-life car
    int modelYear;

    public Car() {

    }
}
In the example above, we created the instance variable named modelYear. Instance variables model real-world car attributes, such as the model year of a car. Finally, the instance variable is represented by the int data type.*/


class Dog {
  
  int age;

	public Dog() {
  
  }


	public static void main(String[] args) {

	}

}


//Classes: Constructor Parameters

/*Parameters allow data types to be created with specified attributes.
Let's add parameters to our Car class constructor:

class Car {

    //Use instance variables to model our Car class after a real-life car
    int modelYear;

    public Car(int year) {

        modelYear = year;
    }
}
In the example above, we add the int parameter year to the Car constructor.

The value of modelYear will equal the int value that is specified when we first use this class constructor.*/


class Dog {
  
  int age;

	public Dog(int dogsAge) {
    
  	age = dogsAge;
    
  }


	public static void main(String[] args) {

	}

}

//The main Method

/*public static void main(String[] args) {

}
This is Java's built-in main method. We will learn more about methods and keywords around the main method later on, but first let's understand what the purpose of main is.

When Java runs your program, the code inside of the main method is executed.
For now, you can ignore the keywords in the main method that we have not yet covered. You will learn about them later in the course.*/


class Dog {
  
  int age;

	public Dog(int dogsAge) {
    
  	age = dogsAge;
    
  }


	public static void main(String[] args) {//**

	}  

}

/*To use the Dog class, we must create an instance of the Dog class. An instance of a class is known as an object in Java.

The example below demonstrates how to create a Car object:

class Car {

    int modelYear;

    public Car(int year) {

        modelYear = year;

    }

    public static void main(String[] args){

        Car myFastCar = new Car(2007);

    }
}
In the example above, we create a Car object named myFastCar. When creating myFastCar, we used the class constructor and specified a value for the required int parameter year.

2007 is the model year of myFastCar. Note that we declared the new object inside the main method.*/


class Dog {
  
  int age;

	public Dog(int dogsAge) {
    
  	age = dogsAge;
    
  }

	public static void main(String[] args) {
    
    Dog spike = new Dog(5);

	}

}

//Methods

/*A method is a pre-defined set of instructions. Methods are declared within a class. Java provides some pre-defined methods available to all classes, but we can create our own as well.

Let's create a new method:

class Car {

    int modelYear;

    public Car(int year) {

        modelYear = year;

    }

    //Our new method to help us get "started"
    public void startEngine() {

        System.out.println("Vroom!");

    }

    public static void main(String[] args){

        Car myFastCar = new Car(2007);

    }
}
In the example above, we added a method called startEngine. When the method is used, it will print out Vroom!. The void keyword will be explained later in this course.

Note that the startEngine method is created outside of the main method, like the constructor was.*/

class Dog {
  
  int age;

	public Dog(int dogsAge) {
    
  	age = dogsAge;
    
  }

	public static void main(String[] args) {
    
    public void bark(){
    
      System.out.println("Woof!");
      
    }
    
    Dog spike = new Dog(5);

	}

}

//Using methods

/*Here is an example of calling a method on an object using the Car class:

class Car {

    int modelYear;

    public Car(int year) {

        modelYear = year;

    }

    public void startEngine() {

        System.out.println("Vroom!");

    }

    public static void main(String[] args){

        Car myFastCar = new Car(2007);
        myFastCar.startEngine();
    }
In the example above, we call the startEngine method on the myFastCar object. Again, this occurs inside of the main method. Running the program results in printing Vroom! to the console.*/

class Dog {
  
  int age;

	public Dog(int dogsAge) {
    
  	age = dogsAge;
    
  }
  
  public void bark() {
		
    System.out.println("Woof!");
    
	}

	public static void main(String[] args) {
    
    Dog spike = new Dog(5);
    spike.bark();

	}

}



//Methods

/*class Car {

    int modelYear;

    public Car(int year) {

        modelYear = year;

    }

    public void startEngine() {
        System.out.println("Vroom!");
    }

    public void drive(int distanceInMiles) {

        System.out.println("Miles driven: " + distanceInMiles);

    }

    public static void main(String[] args){

        Car myFastCar = new Car(2007);
        myFastCar.startEngine();
        myFastCar.drive(1628);

    }
In the example above, we create a drive method that accepts an int parameter called distanceInMiles. In the main method, we call the drive method on the myFastCar object and provide an int parameter of 1628.

Calling the drive method on myFastCar will result in printing Miles driven: 1628 to the console.*/

class Dog {
  
  int age;

	public Dog(int dogsAge) {
    
  	age = dogsAge;
    
  }
  
  public void bark() {
		
    System.out.println("Woof!");
    
	}
	
  public void run(int feet) {
    
    System.out.println("Your dog ran " + feet + " feet!");

	}
  
	public static void main(String[] args) {
    
    Dog spike = new Dog(5);
    spike.bark();
    spike.run(40);

	}

}


//Using Methods

/*The void keyword indicates that no value should be returned by the method after it executes all the logic in the method. If we do want the method to return a value after it finishes running, we can specify the return type.

The void keyword (which means "completely empty") indicates to the method that no value is returned after calling that method.
Alternatively, we can use data type keywords (such as int, char, etc.) to specify that a method should return a value of that type.
An example of indicating a return value for a method is below:

class Car {

    int modelYear;

    public Car(int year) {

        modelYear = year;

    }

    public void startEngine() {

        System.out.println("Vroom!");

    }

    public void drive(int distanceInMiles) {

        System.out.println("Your car drove " + distanceInMiles + " miles!");

    }

    public int numberOfTires() {

        return 4;

    }

    public static void main(String[] args){

        Car myFastCar = new Car(2007)
        myFastCar.startEngine();
        myFastCar.drive(1628);

        int tires = myFastCar.numberOfTires();
        System.out.println(tires);

    }
}
In the example above, we created the numberOfTires method. This method specifies that it will return an int data type. Inside of the method, we used the return keyword to return the value of 4 which is an int type.

Within main, we called the numberOfTires method on myFastCar. Since the method returns an int value of 4, we store the value within an int variable called tires. We then print the value of tires to the console.*/


class Dog {
  
  int age;

	public Dog(int dogsAge) {
    
  	age = dogsAge;
    
  }
  
  public void bark() {
		
    System.out.println("Woof!");
    
	}
	
  public void run(int feet) {
    
    System.out.println("Your dog ran " + feet + " feet!");

	}
  
  public int getAge() {

    return age;
    
	}
  
	public static void main(String[] args) {
    
    Dog spike = new Dog(5);
    spike.bark();
    spike.run(40);
    int spikeAge = spike.getAge();
    System.out.println(spikeAge);

	}

}


//Inheritance

/*One of the object-oriented programming concepts that allows us to reuse and maintain code more efficiently is called inheritance. It is used to share or inherit behavior from another class. Let's look at an example:

class Car extends Vehicle {

    int modelYear;

    public Car(int year) {

        modelYear = year;

    }

    //Other methods omitted for brevity...

    public static void main(String[] args){

        Car myFastCar = new Car(2007)
        myFastCar.checkBatteryStatus();

    }
}
class Vehicle {

    public void checkBatteryStatus() {

        System.out.println("The battery is fully charged and ready to go!");

    }
}
In the example above, the extends keyword is used to indicate that the Car class inherits the behavior defined in the Vehicle class. This makes sense, since a car is a type of vehicle.

Within the main method of Car, we call the checkBatteryStatus method on myFastCar. Since Car inherits from Vehicle, we can use methods defined in Vehicle on Car objects.*/


//Dog.java

class Dog extends Animal {//**inherits from the Animal class.
  
  int age;

	public Dog(int dogsAge) {
    
  	age = dogsAge;
    
  }
  
  public void bark() {
		
    System.out.println("Woof!");
    
	}
	
  public void run(int feet) {
    
    System.out.println("Your dog ran " + feet + " feet!");

	}
  
  public int getAge() {

    return age;
    
	}
  
	public static void main(String[] args) {
    
    Dog spike = new Dog(5);
    spike.bark();
    spike.run(40);
    int spikeAge = spike.getAge();
    System.out.println(spikeAge);
    spike.checkStatus();

	}

}

//**Animal.java

class Animal {

	public void checkStatus() {

		System.out.println("Your pet is healthy and happy!");

	}
}


//Generalizations

/*Class: a blueprint for how a data structure should function
Constructor: instructs the class to set up the initial state of an object
Object: instance of a class that stores the state of a class
Method: set of instructions that can be called on an object
Parameter: values that can be specified when creating an object or calling a method
Return value: specifies the data type that a method will return after it runs
Inheritance: allows one class to use functionality defined in another class*/

//Coffee.java

class Coffee extends Beverage {//**
	
	public Coffee() {

	}
	
	public void addSugar(int cubes) {

		System.out.println("You added " + cubes + " sugar cubes.");

	}

	public static void main(String[] args) {
    
    Coffee myOrder = new Coffee();
    myOrder.addSugar(2);
    myOrder.isFull();

	}
}

//**Beverage.java

class Beverage {
	
	public Beverage() {

	}

	public void isFull() {

		System.out.println("Your order is full!");

	}

	public static void main(String[] args) {

	}

}




//Data Structures Overview

import java.util.*;

public class Olympics {

	public static void main(String[] args) {

		//Some Olympic sports 

		ArrayList<String> olympicSports = new ArrayList<String>();
		olympicSports.add("Archery");
		olympicSports.add("Boxing");
		olympicSports.add("Cricket");
		olympicSports.add("Diving");

		System.out.println("There are " + olympicSports.size() + " Olympic sports in this list. They are: ");

		for (String sport: olympicSports) {
			System.out.println(sport);
		}

		//Host cities and the year they hosted the summer Olympics

		HashMap<String, Integer> hostCities = new HashMap<String, Integer>();

		hostCities.put("Beijing", 2008);
		hostCities.put("London", 2012);
		hostCities.put("Rio de Janeiro", 2016);

		for (String city: hostCities.keySet()) {
			
			if (hostCities.get(city) < 2016) {

				System.out.println(city + " hosted the summer Olympics in " + hostCities.get(city) + ".");

			} else {

				System.out.println(city + " will host the summer Olympics in " + hostCities.get(city) + ".");

			}
		}

	}

}


//For Loop

/*When you provide a set of instructions in a method, you might find that a common task is to manipulate an entire set of data. Java conveniently provides control statements to run a task repeatedly. The control statement we will explore is called the for loop.

The for loop repeatedly runs a block of code until a specified condition is met.

The example below shows how a for loop is used:

for (int counter = 0; counter < 5; counter++) {

    System.out.println("The counter value is: " + counter);

}
The statements within the parentheses of for loop compose the following parts:

Initialization: the int variable named counter is initialized to the value of 0 before the loop is run.
2. Test condition: the Boolean expression counter < 5 is a conditional statement that is evaluated before the code inside the control statement is run every loop. If the expression evaluates to true, the code in the block will run. Otherwise, if the expression evalutes to false, the for loop will stop running.

3. Increment: Each time the loop completes, the increment statement is run. The statement counter++ increases the value of counter by 1 after each loop.

In the example above, the for loop initially executes the code block in the sample code above because the initial value of counter is less than 5, which passes the test condition.

The value of counter is then incremented by 1 in the increment.

The code block will execute again because counter is still less than 5. This cycle will continue until counter is no longer less than 5.

Please note that similar to the if-then statement, no semicolon is necessary.*/
  

public class For {
	public static void main(String[] args) {

		for (int waterLevel = 0; waterLevel < 13; waterLevel++) {

			System.out.println("The pool's water level is at " + waterLevel + " feet.");

		}
		
	}

} 
  

//ArrayList

/*Fantastic! For loops will be useful when reading and manipulating Java data structures. Let's talk about a few data structures that are built into Java. The first data structure we will explore is called the ArrayList.

The ArrayList stores a list of data of a specified type. Let's go through an example of how to create, or declare, an ArrayList of type Integer.

ArrayList<Integer> quizGrades = new ArrayList<Integer>();
ArrayList is a pre-defined Java class. To use it, we must first create an ArrayList object.

In the example above, we create an ArrayList object called quizGrades that will store data types belonging to the <Integer> class (whole numbers).
*/

import java.util.ArrayList;

public class Temperatures {
	
	public static void main(String[] args) {

    ArrayList<Integer> weeklyTemperatures = new ArrayList<Integer>();

	}
}


//ArrayList Manipulation

/*You created an ArrayList in the last exercise to store temperature data, but it does not contain any values yet.

Let's add some values of type Integer to the ArrayList, one by one, like this:

ArrayList<Integer> quizGrades = new ArrayList<Integer>();
quizGrades.add(95);
quizGrades.add(87);
quizGrades.add(83);
In the example above, we call the add method on quizGrades. The add method adds integers to the ArrayList. The values 95, 87, and 83 are added to the list.*/

import java.util.ArrayList;

public class Temperatures {
	
	public static void main(String[] args) {

    ArrayList<Integer> weeklyTemperatures = new 		ArrayList<Integer>();
		weeklyTemperatures.add(78); 
		weeklyTemperatures.add(67);    
		weeklyTemperatures.add(89);    
	}
}


//ArrayList Access

/*We can access the elements of weeklyTemperatures by using an element's index, or position, in the list.

An element's index refers to its location within an ArrayList. ArrayLists in Java are zero-indexed, which means that the first element in an ArrayList is at a position of 0.

Here is an example of accessing the element in the first position of the list:

ArrayList<Integer> quizGrades = new ArrayList<Integer>();
quizGrades.add(95);
quizGrades.add(87);
quizGrades.add(73);

System.out.println( quizGrades.get(0) );
The example above will print out the grade value of 95.

The index of the element containing the value 95 is at position 0 in the ArrayList. We access the value by providing its index to the get method.*/

import java.util.ArrayList;

public class Temperatures {
	
	public static void main(String[] args) {

    ArrayList<Integer> weeklyTemperatures = new 		ArrayList<Integer>();
		weeklyTemperatures.add(78); 
		weeklyTemperatures.add(67);    
		weeklyTemperatures.add(89); 
    weeklyTemperatures.add(94); 
       			System.out.println(weeklyTemperatures.get(1));
	}
}


//ArrayList Insertion

/*To insert new elements into an ArrayList, we can use a slightly different version of the add method that you previously used:

ArrayList<Integer> quizGrades = new ArrayList<Integer>();
quizGrades.add(95);
quizGrades.add(87);
quizGrades.add(73);

quizGrades.add(0, 100);
System.out.println( quizGrades.get(0) );
The example above will print out the grade 100.

The add method will insert the grade 100 at the first position (0) into the list. Since it inserts a new element into the beginning of the ArrayList, all other element indices will be shifted one position higher. The grade 95 is now at index 1.*/

import java.util.ArrayList;

public class TemperaturesB {
	
	public static void main(String[] args) {

		ArrayList<Integer> weeklyTemperatures = new ArrayList<Integer>();
		weeklyTemperatures.add(78);
		weeklyTemperatures.add(67);
    weeklyTemperatures.add(89);
		weeklyTemperatures.add(94);

		weeklyTemperatures.add(2,111);
    
    System.out.println(weeklyTemperatures.get(3));
	}
}


//Iteration

/*for (int i = 0; i < quizGrades.size(); i++) {

    System.out.println( quizGrades.get(i) );

}
In the example above, the for loop above includes the following statements:

Initialization: int variable i is set to 0 which is the first index of an ArrayList.
Test condition: the code in the block will run as long as i is less than the size of quizGrades.
Increment: The code in this block will execute after each loop. In this case,i will increment by 1 with i++ after each loop.
The size method returns an int that represents how many total elements are stored within quizGrades. The example will print out each element within quizGrades in order. The process of going through each element in the ArrayList is called iteration.*/

public class TemperaturesC {
	
	public static void main(String[] args) {

		ArrayList<Integer> weeklyTemperatures = new ArrayList<Integer>();
		weeklyTemperatures.add(78);
		weeklyTemperatures.add(67);
		weeklyTemperatures.add(89);
		weeklyTemperatures.add(94);
		weeklyTemperatures.add(2, 111);
    
    for (int j = 0; j < weeklyTemperatures.size(); j++) {

    System.out.println( weeklyTemperatures.get(j) );

}

		

	}
}


//For Each Loop

/*Here is an example of the concise for each loop:

for (Integer grade : quizGrades){
    System.out.println(grade);
}
In the example above, the colon (:) can be read as "in". The for each loop altogether can be read as "for each Integer element (called grade) in quizGrades, print out the value of grade."

The loop will print out the value of each Integer element in quizGrades.

Note: the for each loop does not require a counter.*/

import java.util.ArrayList;

public class TemperaturesForEach {
	public static void main(String[] args) {

		ArrayList<Integer> weeklyTemperatures = new ArrayList<Integer>();
		weeklyTemperatures.add(78);
		weeklyTemperatures.add(67);
		weeklyTemperatures.add(89); 
		weeklyTemperatures.add(94);
		
		for (Integer temperature : weeklyTemperatures) {
			System.out.println(temperature);
		}
	
	}
}


//HashMap

/*A HashMap contains a set of keys and a value for each key.

If we look up a word in a dictionary, we can get the definition. If you provide a HashMap with a key that exists, you can retrieve the value associated with the key.

Declaring a HashMap is shown in the following example:

HashMap<String, Integer> myFriends = new HashMap<String, Integer>();
In the example above, we create a HashMap object called myFriends. The myFriends HashMap will store keys of String data types and values of type Integer.

Note: the String object allows you to store multiple characters, such as a word in quotations (e.g. "Rats!").*/

import java.util.HashMap;

public class Restaurant {
	public static void main(String[] args) {

	HashMap<String, Integer> restaurantMenu = new HashMap<String, Integer>();
	}
}


//HashMap Manipulation

/*HashMap<String, Integer> myFriends = new HashMap<String, Integer>();

myFriends.put("Mark", 24);
myFriends.put("Cassandra", 25);
myFriends.put("Zenas", 21);
In the example above, we used the put method to add a String key and an associated Integer value. The String key is the text inside double quotes " ". The Integer value is represented by the number.*/

import java.util.HashMap;

public class Restaurant {
	public static void main(String[] args) {

	HashMap<String, Integer> restaurantMenu = new HashMap<String, Integer>();
    
  restaurantMenu.put("Turkey Burger",13);
  restaurantMenu.put("Naan Pizza",11); 
  restaurantMenu.put("Cranberry Kale Salad",10); 
    
    
	}
}


//HashMap Access

/*In order to access a value in a HashMap, we specify the key:

HashMap<String, Integer> myFriends = new HashMap<String, Integer>();

myFriends.put("Mark", 24);
myFriends.put("Cassandra", 25);
myFriends.put("Zenas", 21);

System.out.println( myFriends.get("Zenas") );
In the example above, we call the get method on the myFriends HashMap using the key "Zenas". The console will print the value associated with "Zenas" which is 21.*/
  
import java.util.HashMap;

public class Restaurant {
	public static void main(String[] args) {

	HashMap<String, Integer> restaurantMenu = new HashMap<String, Integer>();
    
  restaurantMenu.put("Turkey Burger",13);
  restaurantMenu.put("Naan Pizza",11); 
  restaurantMenu.put("Cranberry Kale Salad",10); 
    
   System.out.println( restaurantMenu.get("Naan Pizza") ); 
	}
}


//MashMap Iteration

/*HashMap<String, Integer> myFriends = new HashMap<String, Integer>();

myFriends.put("Mark", 24);
myFriends.put("Cassandra", 25);
myFriends.put("Zenas", 21);

System.out.println( myFriends.size() );

for (String name: myFriends.keySet()) {

    System.out.println(name + " is age: " + myFriends.get(name));

}
In the example above, the size method of HashMap prints out the size of the myFriends instance. As a result, the console prints out 3 since there are 3 key-value pairs.

Next, we use a for each loop to iterate over each key in myFriends. The keySet method of HashMap returns a list of keys.

Inside the loop, we access the current key name and use the get method of HashMap to access the value. The console will print out the names and ages of each of my friends.*/
 

import java.util.HashMap;

public class RestaurantForEach {
	public static void main(String[] args) {

		HashMap<String, Integer> restaurantMenu = new HashMap<String, Integer>();

		restaurantMenu.put("Turkey Burger", 13);
		restaurantMenu.put("Naan Pizza", 11);
		restaurantMenu.put("Cranberry Kale Salad", 10);

		System.out.println(restaurantMenu.size());

		for (String item : restaurantMenu.keySet()) {

			System.out.println("A " + item + " costs " + restaurantMenu.get(item) + " dollars.");

		}

	}
}






  

